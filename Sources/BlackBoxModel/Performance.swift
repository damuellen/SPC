// SPDX-License-Identifier: Apache-2.0
//
// (C) Copyright 2016 - 2023
// Daniel MÃ¼llenborn, TSK Flagsol Engineering

import Units

/// A struct representing the performance data of a solar power plant.
public struct PlantPerformance: MeasurementsConvertible, Encodable {

  /// The thermal energy data of the solar power plant.
  internal(set) public var thermal: ThermalEnergy
  
  /// The electric power data of the solar power plant.
  internal(set) public var electric: ElectricPower
  
  /// The fuel consumption data of the solar power plant.
  internal(set) public var fuel: FuelConsumption
  
  /// The parasitics data of the solar power plant.
  internal(set) public var parasitics: Parasitics

  /// Calculates the performance data for the given collection of `PlantPerformance` instances.
  /// - Parameters:
  ///   - performance: A collection of `PlantPerformance` instances.
  ///   - fraction: The fraction by which the performance data should be added.
  mutating func callAsFunction(_ performance: some RangeReplaceableCollection<PlantPerformance>, timeProportion: Double) {
    self.thermal = performance.map(\.thermal).accumulate(timeProportion: timeProportion)
    self.fuel = performance.map(\.fuel).accumulate(timeProportion: timeProportion)
    self.parasitics = performance.map(\.parasitics).accumulate(timeProportion: timeProportion)
    self.electric = performance.map(\.electric).accumulate(timeProportion: timeProportion)
  }

  /// Returns an array of the performance values of the `PlantPerformance`.
  var values: [Double] {
    thermal.values + fuel.values + parasitics.values + electric.values
  }

  /// The array of tuples representing the measurements for `PlantPerformance`.
  static var measurements: [(name: String, unit: String)] {
    ThermalEnergy.measurements + FuelConsumption.measurements
      + Parasitics.measurements + ElectricPower.measurements
  }
}

extension PlantPerformance {
  /// Initializes a `PlantPerformance` instance.
  /// - Parameters:
  ///   - plant: The `Plant` instance from which the performance data is extracted.
  init(_ plant: Plant) {
    self.thermal = plant.heatFlow
    self.electric = plant.electricity
    self.fuel = plant.fuelConsumption
    self.parasitics = plant.electricalParasitics
  }
  /// Initializes an empty `PlantPerformance` instance.
  init() {
    self.thermal = ThermalEnergy()
    self.electric = ElectricPower()
    self.fuel = FuelConsumption()
    self.parasitics = Parasitics()
  }
}
import Units

/// A struct representing the electric power data of a solar power plant.
public struct ElectricPower: Encodable, MeasurementsConvertible {
  /// The demand of electric power in MWh.
  internal(set) public var demand: Double = .zero
  /// The gross electric power in MWh.
  internal(set) public var gross: Double = .zero
  /// The shared electric power in MWh.
  internal(set) public var shared: Double = .zero
  /// The electric power generated by the power block in MWh.
  internal(set) public var powerBlock: Double = .zero
  /// The electric power stored in the storage system in MWh.
  internal(set) public var storage: Double = .zero
  /// The electric power generated by the gas turbine in MWh.
  internal(set) public var gasTurbine: Double = .zero
  /// The gross electric power generated by the steam turbine in MWh.
  internal(set) public var steamTurbineGross: Double = .zero
  /// The gross electric power generated by the gas turbine in MWh.
  internal(set) public var gasTurbineGross: Double = .zero
  /// The electric power generated by the photovoltaic system in MWh.
  internal(set) public var photovoltaic: Double = .zero
  /// The parasitics electric power consumption in MWh.
  internal(set) public var parasitics: Double = .zero
  /// The net electric power in MWh.
  internal(set) public var net: Double = .zero
  /// The electric power consumption in MWh.
  internal(set) public var consum: Double = .zero

  /// An array of electric power values.
  var values: [Double] {
    [demand, steamTurbineGross, photovoltaic, storage, parasitics, shared, net, consum]
  }

  /// An array of tuples representing the measurements for `ElectricPower`.
  static var measurements: [(name: String, unit: String)] {
    [
      ("Electric|Demand", "MWh e "),
      ("Electric|SteamTurbineGross", "MWh e "),
      ("Electric|Photovoltaic", "MWh e "),
      ("Electric|Storage", "MWh e "),
      ("Electric|Parasitics", "MWh e "),
      ("Electric|Shared", "MWh e "),
      ("Electric|Net", "MWh e "),
      ("Electric|Consum", "MWh e "),
    ]
  }

  /// Estimates the demand of electric power based on the plant's design and operation parameters.
  /// - Returns: The estimate of electric power demand in MWh.
  @discardableResult mutating func estimateDemand() -> Double {
    var estimate = 0.0
    if Design.hasGasTurbine {
      demand = GridDemand.current.ratio * (Design.layout.powerBlock - Design.layout.gasTurbine)
      estimate = demand * Simulation.parameter.electricalParasitics
      // Iter. start val. for parasitics, 10% demand
      demand += estimate
    } else {
      let power = SteamTurbine.parameter.power.max
      demand = GridDemand.current.ratio * power
      estimate = storage
    }
    return estimate
  }

  /// Calculates the total electric power values based on the provided `Parasitics`.
  /// - Parameter parasitics: The `Parasitics` data used for totalization.
  mutating func totalize(parasitics: Parasitics) {
    // + GasTurbine = total produced electricity
    let solarField = parasitics.solarField
    storage = parasitics.storage

    // electricPerformance.parasiticsBU =
    // electricalParasitics.heater + electricalParasitics.boiler
    powerBlock = parasitics.powerBlock
    shared = parasitics.shared

    self.parasitics = solarField + gasTurbine + parasitics.powerBlock + parasitics.shared
    self.parasitics *= Simulation.adjustmentFactor.electricalParasitics
  }

  /// Calculates the electric power consumption and net electric power.
  mutating func consumption() {
    net = gross
    net -= parasitics

    if net < .zero {
      consum = -net
      net = .zero
    } else {
      consum = .zero
    }
  }
}

/// An extension to provide additional functionalities to `RangeReplaceableCollection` with `Element` of type `ElectricPower`.
extension RangeReplaceableCollection where Element==ElectricPower {

  /// Calculates the sum of electric power values for the collection of `ElectricPower` instances multiplied by the given fraction.
  /// - Parameter fraction: The fraction by which the electric power values should be added.
  /// - Returns: An `ElectricPower` instance containing the summed electric power values.
  func accumulate(timeProportion: Double) -> ElectricPower {
    var result = ElectricPower()
    for values in self {
      result.demand += values.demand * timeProportion
      result.gross += values.gross * timeProportion
      result.steamTurbineGross += values.steamTurbineGross * timeProportion
      // self.gasTurbineGross += values.gasTurbineGross * fraction
      result.photovoltaic += values.photovoltaic * timeProportion
      result.shared += values.shared * timeProportion
      result.parasitics += values.parasitics * timeProportion
      result.storage += values.storage * timeProportion
      result.net += values.net * timeProportion
      result.consum += values.consum * timeProportion
    }
    return result
  }
}

/// A struct representing the parasitics of a solar power plant.
public struct Parasitics: Encodable, MeasurementsConvertible {
  /// Parasitics for the boiler.
  internal(set) public var boiler: Double = .zero
  /// Parasitics for the gas turbine.
  internal(set) public var gasTurbine: Double = .zero
  /// Parasitics for the heater.
  internal(set) public var heater: Double = .zero
  /// Parasitics for the power block.
  internal(set) public var powerBlock: Double = .zero
  /// Parasitics for the shared components.
  internal(set) public var shared: Double = .zero
  /// Parasitics for the solar field.
  internal(set) public var solarField: Double = .zero
  /// Parasitics for the storage system.
  internal(set) public var storage: Double = .zero

  /// Array of parasitics values.
  var values: [Double] {
    [solarField, powerBlock, storage, shared, 0, gasTurbine]
  }

  /// Array of parasitics measurements.
  static var measurements: [(name: String, unit: String)] {
    [
      ("Parasitics|SolarField", "MWh e "), ("Parasitics|PowerBlock", "MWh e "),
      ("Parasitics|Storage", "MWh e "), ("Parasitics|Shared", "MWh e "),
      ("Parasitics|Backup", "MWh e "), ("Parasitics|GasTurbine", "MWh e "),
    ]
  }
}

/// Extension for RangeReplaceableCollection of Parasitics.
extension RangeReplaceableCollection where Element == Parasitics {
  /// Returns the sum of parasitics values with the given fraction.
  func accumulate(timeProportion: Double) -> Parasitics {
    var result = Parasitics()
    for values in self {
      result.solarField += values.solarField * timeProportion
      result.powerBlock += values.powerBlock * timeProportion
      result.storage += values.storage * timeProportion
      result.shared += values.shared * timeProportion
    // parasiticsBackup += electricalParasitics
      result.gasTurbine += values.gasTurbine * timeProportion
    }
    return result
  }
}

/// A struct representing the thermal energy of a solar power plant.
public struct ThermalEnergy: Encodable, MeasurementsConvertible {
  /// Thermal energy from solar power.
  internal(set) public var solar: Power = .zero
  /// Thermal energy transferred to storage.
  internal(set) public var toStorage: Power = .zero
  /// Minimum thermal energy transferred to storage.
  internal(set) public var toStorageMin: Power = .zero
  /// Thermal energy stored.
  internal(set) public var storage: Power = .zero
  /// Thermal energy from the heater.
  internal(set) public var heater: Power = .zero
  /// Thermal energy from the boiler.
  internal(set) public var boiler: Power = .zero
  /// Thermal energy from waste heat recovery.
  internal(set) public var wasteHeatRecovery: Power = .zero
  /// Thermal energy from the heat exchanger.
  internal(set) public var heatExchanger: Power = .zero
  /// Thermal energy from production.
  internal(set) public var production: Power = .zero
  /// Thermal energy demand.
  internal(set) public var demand: Power = .zero
  /// Thermal energy dumping.
  internal(set) public var dumping: Power = .zero
  /// Thermal energy for start-up.
  internal(set) public var startUp: Power = .zero

  /// Returns the thermal energy balance.
  var balance: Power { production - demand }

  /// Array of thermal energy values.
  var values: [Double] {
    [
      demand.megaWatt, solar.megaWatt, dumping.megaWatt,
      toStorage.megaWatt, storage.megaWatt,
      heater.megaWatt, heatExchanger.megaWatt,
      startUp.megaWatt, production.megaWatt
    ]
  }

  /// Array of thermal energy measurements.
  static var measurements: [(name: String, unit: String)] {
    [
      ("Thermal|Demand", "MWh th"),
      ("Thermal|Solar", "MWh th"), ("Thermal|Dumping", "MWh th"),
      ("Thermal|ToStorage", "MWh th"), ("Thermal|Storage", "MWh th"),
      ("Thermal|Heater", "MWh th"), ("Thermal|HeatExchanger", "MWh th"),
      ("Thermal|Startup", "MWh th"), ("Thermal|Production", "MWh th")
    ]
  }

  /// Calculates the heat supplied by the solar field.
  mutating func solarProduction(_ solarField: SolarField) {
    solar.kiloWatt = solarField.massFlow.rate * solarField.heat

    if solar > .zero {
      production = solar
    } else if case .freeze = solarField.operationMode {
      solar = .zero
      production = solar
    } else {
      solar = .zero
      production = .zero
    }

    if case .defocus(let ratio) = solarField.operationMode {
      dumping = (solar / ratio.quotient) * (1 - ratio.quotient)
    } else {
      dumping = .zero
    }
  }
}

/// Extension for RangeReplaceableCollection of ThermalEnergy.
extension RangeReplaceableCollection where Element == ThermalEnergy {
  /// Returns the sum of thermal energy values with the given fraction.
  func accumulate(timeProportion: Double) -> ThermalEnergy {
    var result = ThermalEnergy()
    for values in self {
      result.demand += values.demand * timeProportion
      result.solar += values.solar * timeProportion
      result.toStorage += values.toStorage * timeProportion
      result.storage += values.storage * timeProportion
      result.heater += values.heater * timeProportion
      result.heatExchanger += values.heatExchanger * timeProportion
      result.startUp += values.startUp * timeProportion
      result.wasteHeatRecovery += values.wasteHeatRecovery * timeProportion
      result.boiler += values.boiler * timeProportion
      result.dumping += values.dumping * timeProportion
      result.production += values.production * timeProportion
    }
    return result
  }
}

/// A struct representing the fuel consumption of a solar power plant.
public struct FuelConsumption: Encodable, MeasurementsConvertible {
  /// Fuel consumption for the backup system.
  internal(set) public var backup: Double = .zero
  /// Fuel consumption for the boiler.
  internal(set) public var boiler: Double = .zero
  /// Fuel consumption for the heater.
  internal(set) public var heater: Double = .zero
  /// Fuel consumption for the gas turbine.
  internal(set) public var gasTurbine: Double = .zero

  /// Combined fuel consumption for the boiler and heater.
  var combined: Double { boiler + heater }

  /// Total fuel consumption for all components.
  var total: Double { boiler + heater + gasTurbine }

  /// Array of fuel consumption values.
  var values: [Double] { [backup, boiler, heater, gasTurbine, combined] }

  /// Array of fuel consumption measurements.
  static var measurements: [(name: String, unit: String)] {
    [
      ("FuelConsumption|Backup", "MWh"), ("FuelConsumption|Boiler", "MWh"),
      ("FuelConsumption|Heater", "MWh"), ("FuelConsumption|GasTurbine", "MWh"),
      ("FuelConsumption|Combined", "MWh"),
    ]
  }
}

/// Extension for RangeReplaceableCollection of FuelConsumption.
extension RangeReplaceableCollection where Element == FuelConsumption {
  /// Returns the sum of fuel consumption values with the given fraction.
  func accumulate(timeProportion: Double) -> FuelConsumption {
    var result = FuelConsumption()
    for fuel in self {
      result.backup += fuel.backup * timeProportion
      result.boiler += fuel.boiler * timeProportion
      result.heater += fuel.heater * timeProportion
      result.gasTurbine += fuel.gasTurbine * timeProportion
    }
    return result
  }
}

/// Extension for PlantPerformance providing a custom description.
extension PlantPerformance: CustomStringConvertible {
  /// Returns a string representation of PlantPerformance with multi-bar information.
  public var description: String {
    thermal.multiBar + electric.multiBar + fuel.multiBar + parasitics.multiBar
  }
}
